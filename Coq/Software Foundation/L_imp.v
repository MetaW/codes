(*
  contents:
  1. AST for Imp
  2. Automation/tactical
      -try tactical
      -; tactical (simple form)
      -; tactical (general form)
      -repeat tactical
  3. Defining New Tactic Notations
  4. omega
  5. More handy tactics.
  6. evalution as relation
  7. 提前定义Notation
  8. 函数与关系的等价性
  9. 函数or关系？
  10.lookup identifer in imp
  11.add command to imp
  12.eval imp command
  13.用关系定义的ceval的确定性
  14.对imp程序进行推理
  15.给imp程序加break语句(TODO)
*)

Require Import Coq.Bool.Bool.
Require Import Coq.Arith.Arith.
Require Import Coq.Arith.EqNat.
Require Import Coq.omega.Omega.
Require Import Coq.Lists.List.
Import ListNotations.

Require Import H_maps.



Module Aexp.

(*AST for Imp*)
Inductive aexp : Type :=
| ANum    : nat -> aexp
| APlus   : aexp -> aexp -> aexp
| AMult   : aexp -> aexp -> aexp
| AMinus  : aexp -> aexp -> aexp.


Inductive bexp : Type :=
| BTrue   : bexp
| BFalse  : bexp
| BEq     : aexp -> aexp -> bexp
| BLe     : aexp -> aexp -> bexp
| BNot    : bexp -> bexp
| BAnd    : bexp -> bexp -> bexp.




Fixpoint aeval (a : aexp) : nat := 
    match a with
    | ANum n => n
    | APlus n m => (aeval n) + (aeval m)
    | AMult n m => (aeval n) * (aeval m)
    | AMinus n m => (aeval n) - (aeval m)
    end.

Fixpoint beval (b : bexp) : bool :=
    match b with
    | BTrue => true
    | BFalse => false
    | BEq n m => beq_nat (aeval n) (aeval m)
    | BLe n m => leb (aeval n) (aeval m)
    | BNot n => negb (beval n)
    | BAnd n m => andb (beval n) (beval m)
    end.






(* Automation *)
(*------------------------------------------------------*)
(*
Tacticals is Coq's term for tactics that take other 
tactics as arguments — "higher-order tactics".
*)



(* try tactical *)
(*
If T is a tactic, then try T is a tactic that is just 
like T except that, if T fails, try T successfully 
does nothing at all (instead of failing).
*)
Theorem silly : forall a, aeval a = aeval a.
Proof.
  intros.
  try reflexivity. (* succeed *)
Qed.

Theorem silly2 : forall P, P -> P.
Proof.
  intros.
  try reflexivity. (* instead of fail, do noting here *)
  apply X.
Qed.







(* ; tactical (simple form) *)
(*
the ; tactical takes two tactics as arguments. The 
compound tactic T;T' first performs T and then performs 
T' on each subgoal generated by T.

eg: 
inducton n; simpl; intros; simpl; reflexivity; auto.
*)

Lemma foo : forall n, leb 0 n = true.
Proof.
  intros.
  induction n.
    -simpl. reflexivity.
    -simpl. reflexivity.
Qed.

Lemma foo' : forall n, leb 0 n = true.
Proof.
  intros.
  (induction n; simpl; reflexivity). (* here *)
Qed.

(*
try 与 ; 配合可以减少很多重复的证明
syntex:
try (tactic1; tactic2; tactic3).

注意：try失败后会把证明直接恢复到使用try之前的状态，而不是
     失败的那一条tactic之前的状态，所以不要过早使用try,可以
     用;产生多个目标，之后再用try尝试完成每一个目标。
     eg: 
     induction xx; try (simpl; xx; xx).

Coq experts often use this "...; try... " idiom after 
a tactic like induction to take care of many similar 
cases all at once. Naturally, this practice has an analog 
in informal proofs.
*)







(* ; tactical(general form) *)
(*
T; [T1 | T2 | ... | Tn]
is a tactic that first performs T and then performs T1 
on the first subgoal generated by T, performs T2 on the 
second subgoal, etc.


T;T' 仅仅是一种特例, 它是下面这种特例的简写：
T; [T' | T' | ... | T']
*)









(* repeat tactical *)
(*
The repeat tactical takes another tactic and keeps 
applying this tactic until it fails.
repeat T 只有T失败时才会停止，否则一直重复下去，所以repeat simpl.这样
的写法会陷入死循环，因为simpl永远都会成功。
*)
Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].
Proof.
  unfold In.
  repeat (try (left; reflexivity); right).
Qed.











(* Defining New Tactic Notations *)
(*
1. "Tactic Notation"能够把多个tactic打包成一个命令。
2. 使用built-in programming language Ltac。
3. There is also an OCaml API, which can be used to 
   build tactics that access Coq's internal structures 
   at a lower level。
*)
Tactic Notation "simpl_and_try" tactic(c) :=
  simpl; try c.









(* omega *)
(*
If the goal is a universally quantified formula made out of
  -numeric constants, addition (+/S), subtraction (-/pred), and
   multiplication by constants (this is what makes it Presburger 
   arithmetic),
  -equality (= and ≠) and inequality (≤)
  -the logical connectives ∧, ∨, ¬, and →,
then invoking omega will either solve the goal or tell you 
that it is actually false.
*)
Example silly_presburger_example : 
  forall m n o p, m + n <= n + o /\ o + 3 = p + 3 -> m <= p.
Proof.
  intros.
  omega.
Qed.










(* more handy tactics *)
(*
下面是一些可能提供方便的tactics:
  1. clear H    :将Hypothesis H从上下文中删除。
  2. subst e    :从上下文中找到x=e或e=x这样的假设，并用e替换上下文
                 中所有的x，再把这个假设删除。
  3. rename xx into YY 
                :将上下文中的所有名字的XX替换为YY，对hypothesis和
                 identifer都有效。
  4. assumption :从上下文中找到一个假设H,并且H与当前的目标匹配，如果
                 找到了它的行为与apply H一样。
  5. contradiction :从上下文中找到一个假设H,并且假设H在逻辑上等价于
                    False，如果找到了就解决当前goal。
  6. constructor  :从当前环境中找到一个归纳定义的构造子c，它能够解决
                   当前的goal，如果找到了就等价于apply c
*)










(* evalution as relation *)
Module aevalR_first_try.

Inductive aevalR : aexp -> nat -> Prop :=
| E_ANum  : forall n, aevalR (ANum n) n
| E_APlus : forall e1 e2 n1 n2, aevalR e1 n1 -> aevalR e2 n2
            -> aevalR (APlus e1 e2) (n1 + n2)
| E_AMult : forall e1 e2 n1 n2, aevalR e1 n1 -> aevalR e2 n2
            -> aevalR (AMult e1 e2) (n1 * n2)
| E_AMinus: forall e1 e2 n1 n2, aevalR e1 n1 -> aevalR e2 n2
            -> aevalR (AMinus e1 e2) (n1 - n2).

Notation "e '\\' n" := (aevalR e n) 
                       (at level 50, left associativity)
                    : type_scope.

End aevalR_first_try.








(* 提前定义Notation *)
(* 这样在下面的定义中就可以直接使用Notation了 *)
Reserved Notation "e '\\' n" (at level 50, left associativity).
Inductive aevalR : aexp -> nat -> Prop :=
| E_ANum  : forall n, (ANum n) \\ n
| E_APlus : forall e1 e2 n1 n2, e1 \\ n1 -> e2 \\ n2
            -> (APlus e1 e2) \\ (n1 + n2)
| E_AMult : forall e1 e2 n1 n2, e1 \\ n1 -> e2 \\ n2
            -> (AMult e1 e2) \\ (n1 * n2)
| E_AMinus: forall e1 e2 n1 n2, e1 \\ n1 -> e2 \\ n2
            -> (AMinus e1 e2) \\ (n1 - n2)
where "e '\\' n" := (aevalR e n) : type_scope.









(* 函数与关系的等价性 *)
Theorem aeval_iff_aevalR : forall e n, e \\ n <-> aeval e = n.
Proof.
  split.
    -intros; induction H; try(subst; reflexivity).
    -generalize dependent n.
     induction e; simpl; intros; subst; constructor;
     try(apply IHe1; reflexivity); try(apply IHe2; reflexivity).
Qed.











(* 函数or关系？ *)
(*
大多数情况下函数和关系都可以，但某些情况下关系比函数更方便：
比如
1.对于除法：div m n, 当n=0时函数不好处理，而关系好定义。
2.对random求值返回一个随机数时，函数不好实现，而关系容易定义。

因为函数在某些输入情况下很难处理，或函数本身就不好实现，而关系一般都比较
好定义。关系比函数更强大。

一般情况下，函数与关系都可以，但函数有以下好处：
    都是确定性的，证明时可以自动花间，可以导出到OCaml或Haskell代码。
而关系有以下缺点：
The cost of defining function as a relation is that we need 
to construct proofs rather than just letting Coq's computation 
mechanism do it for us.
*)
End Aexp.












(* lookup identifer in imp *)
Definition state := total_map nat.  (* define state type *)
Definition empty_state := t_empty 0.

Inductive aexp : Type :=
| ANum : nat -> aexp
| AId  : id -> aexp
| APlus   : aexp -> aexp -> aexp
| AMult   : aexp -> aexp -> aexp
| AMinus  : aexp -> aexp -> aexp.

Definition W : id := Id "W".
Definition X : id := Id "X".
Definition Y : id := Id "Y".
Definition Z : id := Id "Z".

Inductive bexp : Type :=
| BTrue   : bexp
| BFalse  : bexp
| BEq     : aexp -> aexp -> bexp
| BLe     : aexp -> aexp -> bexp
| BNot    : bexp -> bexp
| BAnd    : bexp -> bexp -> bexp.

Fixpoint aeval (st : state) (a : aexp) : nat := 
    match a with
    | ANum n => n
    | AId id => st id
    | APlus n m => (aeval st n) + (aeval st m)
    | AMult n m => (aeval st n) * (aeval st m)
    | AMinus n m => (aeval st n) - (aeval st m)
    end.

Fixpoint beval (st : state) (b : bexp) : bool :=
    match b with
    | BTrue => true
    | BFalse => false
    | BEq n m => beq_nat (aeval st n) (aeval st m)
    | BLe n m => leb (aeval st n) (aeval st m)
    | BNot n => negb (beval st n)
    | BAnd n m => andb (beval st n) (beval st m)
    end.


Example aexp1 : aeval (t_update empty_state X 5) 
                      (APlus (ANum 3) (AMult (AId X) (ANum 2))) = 13.
Proof.
  simpl. reflexivity.
Qed.










(* add command to imp *)
Inductive com : Type :=
| CSkip : com
| CAss  : id -> aexp -> com
| CSeq  : com -> com -> com
| CIf   : bexp -> com -> com -> com
| CWhile: bexp -> com -> com.


(* add some notation to make it convenient to write AST *)
Notation " 'SKIP' " := CSkip.
Notation "x '::=' a" := (CAss x a) (at level 60).
Notation "c1 ;; c2" :=
  (CSeq c1 c2) (at level 80, right associativity).
Notation "'WHILE' b 'DO' c 'END'" :=
  (CWhile b c) (at level 80, right associativity).
Notation "'IFB' c1 'THEN' c2 'ELSE' c3 'FI'" :=
  (CIf c1 c2 c3) (at level 80, right associativity).

(*example*)
(* 其中X,Y,Z均为上面定义的Id类型 *)
Definition fact_in_coq := 
  Z ::= AId X;;
  Y ::= (ANum 1);;
  WHILE (BNot (BEq (AId Z) (ANum 0))) DO
    Y ::= AMult (AId Y) (AId Z);;
    Z ::= AMinus (AId Z) (ANum 1)
  END.










(* eval imp command *)
(*
because eval doesn't terminate on all inputs, so it cannot be 
written in Coq — at least not without additional tricks.

So we will make evaluation as relation:
*)

Reserved Notation "c1 '/' st '\\' st'" (at level 40, st at level 39).
Inductive ceval : com -> state -> state -> Prop :=
| E_Skip : forall st, ceval SKIP st st
| E_Seq  : forall c1 c2 st st1 st2, ceval c1 st st1 -> 
                                    ceval c2 st1 st2 ->
                                    ceval (c1;;c2) st st2
| E_Ass  : forall st x a n, aeval st a = n -> 
                  (x ::= a) / st \\ (t_update st x n)
| E_IfTrue : forall b1 c1 c2 st st1, beval st b1 = true ->
                    c1 / st \\ st1 -> ceval (CIf b1 c1 c2) st st1
| E_IfFalse: forall b1 c1 c2 st st1, beval st b1 = false ->
                    c2 / st \\ st1 -> ceval (CIf b1 c1 c2) st st1
| E_WhileEnd : forall b c st, beval st b = false -> 
                      (CWhile b c) / st \\ st
| E_WhileLoop : forall b c st st1 st2, beval st b = true ->
                       c / st \\ st1 -> (CWhile b c) / st1 \\ st2 ->
                       (CWhile b c) / st \\ st2
where "c1 '/' st '\\' st'" := (ceval c1 st st').


(* Exercise *)
Example ceval_example1:
    (X ::= ANum 2;;
     IFB BLe (AId X) (ANum 1)
       THEN Y ::= ANum 3
       ELSE Z ::= ANum 4
     FI)
   / empty_state
   \\ (t_update (t_update empty_state X 2) Z 4).
Proof.
  apply E_Seq with (st1 := (t_update empty_state X 2)).
  -apply E_Ass. simpl. auto.
  -apply E_IfFalse.
    +simpl. auto.
    +apply E_Ass. auto.
Qed.


Example ceval_example2:
    (X ::= ANum 0;; Y ::= ANum 1;; Z ::= ANum 2) / empty_state \\
    (t_update (t_update (t_update empty_state X 0) Y 1) Z 2).
Proof.
  apply E_Seq with (t_update empty_state X 0).
  -apply E_Ass. auto.
  -apply E_Seq with (t_update (t_update empty_state X 0) Y 1);
   try(apply E_Ass; auto).
Qed.


Definition pup_to_n :com :=
  Y ::= (ANum 0);;
  WHILE BNot (BEq (AId X) (ANum 0)) DO
    Y ::= APlus (AId Y) (AId X);;
    X ::= AMinus (AId X) (ANum 1)
  END.

Theorem pup_to_2_ceval :
  pup_to_n / (t_update empty_state X 2) \\
    t_update (t_update (t_update (t_update (t_update (t_update empty_state
      X 2) Y 0) Y 2) X 1) Y 3) X 0.
Proof.
  unfold pup_to_n.
  apply E_Seq with (t_update (t_update empty_state X 2) Y 0).
  -apply E_Ass. auto.
  -apply E_WhileLoop with (t_update (t_update (t_update 
                          (t_update empty_state X 2) Y 0)
                           Y 2) X 1).
   +auto.
   +apply E_Seq with (t_update
     (t_update (t_update empty_state X 2) Y 0)
     Y 2).
    *apply E_Ass. auto.
    *apply E_Ass. auto.
   +apply E_WhileLoop with (t_update
      (t_update
        (t_update
            (t_update
              (t_update
                  (t_update empty_state X 2) Y
                  0) Y 2) X 1) Y 3) X 0).
    *auto.
    *apply E_Seq with (t_update
     (t_update
        (t_update
           (t_update
              (t_update empty_state X 2) Y 0)
           Y 2) X 1) Y 3).
      **apply E_Ass. auto.
      **apply E_Ass. auto.
    *apply E_WhileEnd.
      **auto.
Qed.








(* 用关系定义的ceval的确定性 *)
Theorem ceval_deterministic: forall c st st1 st2,
     c / st \\ st1  ->
     c / st \\ st2 ->
     st1 = st2.
Proof.
  Admitted.











(* 对imp程序进行推理!!! *)

Theorem plus2_spec : forall st n st',
  st X = n ->
  (X ::= (APlus (AId X) (ANum 2))) / st \\ st' ->
  st' X = n + 2.
Proof.
  intros.
  inversion H0.
  -simpl in H5. rewrite H in H5.
   rewrite H5.
   unfold t_update.
   simpl.
   auto.
Qed.


Theorem loop_never_stops : forall st st' , 
                           not 
                           (WHILE BTrue DO
                                SKIP
                              END
                            / st \\st').
Proof.
  intros st st' contra.
  remember (WHILE BTrue DO SKIP END) as loopdef.
  -induction contra;
   try(inversion Heqloopdef).
    +subst. inversion H.
    +subst. apply IHcontra2. reflexivity.  
Qed.



Fixpoint no_whiles (c : com) : bool :=
  match c with
  | SKIP       => true
  | _ ::= _    => true
  | c1 ;; c2  => andb (no_whiles c1) (no_whiles c2)
  | IFB _ THEN ct ELSE cf FI => andb (no_whiles ct) (no_whiles cf)
  | WHILE _ DO _ END  => false
  end.

Inductive no_whilesR : com -> Prop :=
| NW_Skip : no_whilesR SKIP
| NW_Ass  : forall x a, no_whilesR (CAss x a)
| NW_Seq  : forall c1 c2, no_whilesR c1 -> no_whilesR c2 -> 
                          no_whilesR (CSeq c1 c2)
| NW_If   : forall b c1 c2, no_whilesR c1 -> no_whilesR c2 ->
                            no_whilesR (IFB b THEN c1 ELSE c2 FI).

Theorem no_whiles_eqv : forall c, no_whiles c = true <-> no_whilesR c.
Proof.
  split.
  -intros. induction c;
   try(constructor); 
   try apply IHc1; try apply IHc2; try simpl in H; 
   try apply andb_true_iff in H; try apply H; try inversion H.
  -intros. induction c;
   try(simpl; auto);
   try inversion H; try apply IHc1 in H2; try apply IHc2 in H3; subst;
   try rewrite H2; try rewrite H3; auto.
Qed.


Theorem no_whiles_terminating : forall c st, no_whilesR c -> 
                                exists st1, c / st \\ st1.
Proof.
  intros. 
  generalize dependent st.
  induction H.
  -intros. exists st. apply E_Skip.
  -intros. exists (t_update st x (aeval st a)). apply E_Ass. auto.
  -intros. destruct IHno_whilesR1 with st as [st1].
   destruct IHno_whilesR2 with st1 as [st2].
   exists st2. apply E_Seq with st1; try apply H1; try apply H2.
  -intros. destruct IHno_whilesR1 with st as [st1].
   destruct IHno_whilesR2 with st as [st2].
   remember (beval st b) as cond.
   destruct cond.
   +exists st1. apply E_IfTrue; auto.
   +exists st2. apply E_IfFalse; auto.
Qed.



